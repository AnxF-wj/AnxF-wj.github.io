<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMU-15-445_FirstHomeWork</title>
    <url>/2023/05/25/CMU-15-445_first/</url>
    <content><![CDATA[<h2 id="1-Q1-0-points-q1-sample"><a href="#1-Q1-0-points-q1-sample" class="headerlink" title="1. Q1 [0 points] (q1_sample):"></a>1. Q1 [0 points] (q1_sample):</h2><p>The purpose of this query is to make sure that the formatting of your output matches exactly the formatting of our auto-grading script.<br>Details: List all Category Names ordered alphabetically.<br>Answer: Here’s the correct SQL query and expected output:</p>
<p>在sqlite3中输入以下命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(<span class="keyword">language</span>)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> akas</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">language</span></span><br><span class="line">   ...<span class="operator">&gt;</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>
<p>得到输出<br>af<br>ar<br>az<br>be<br>bg<br>bn<br>bs<br>ca<br>cmn</p>
<h2 id="2-Q2-5-points-q2-sci-fi"><a href="#2-Q2-5-points-q2-sci-fi" class="headerlink" title="2. Q2 [5 points] (q2_sci_fi):"></a>2. Q2 [5 points] (q2_sci_fi):</h2><p>Find the 10 <code>Sci-Fi</code> works with the longest runtimes.<br>Details: Print the title of the work, the premiere date, and the runtime. The column listing the runtime should be suffixed with the string “ (mins)”, for example, if the runtime_mins value is <code>12</code>, you should output 12 (mins). Note a work is Sci-Fi even if it is categorized in multiple genres, as long as Sci-Fi is one of the genres.<br>Your first row should look like this: Cicak-Man 2: Planet Hitam|2008|999 (mins)</p>
<p>使用以下命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> primary_title,premiered,runtime_minutes <span class="operator">||</span> <span class="string">&#x27;(mins)&#x27;</span> <span class="keyword">as</span> runtime <span class="keyword">FROM</span> titles <span class="keyword">WHERE</span> genres <span class="keyword">like</span> <span class="string">&#x27;%Sci-Fi%&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> runtime_minutes <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>
<p>得到输出<br>Cicak-Man 2: Planet Hitam|2008|999(mins)<br>Project Hail Mary|2021|970(mins)<br>Wholy|2018|660(mins)<br>Tales from the Void|2016|600(mins)<br>Blade Runner: Czy androidy marza o elektrycznych owcach? (Audioplay)|2012|403(mins)<br>Cold Lazarus|1996|300(mins)<br>Phantom Gear|2021|300(mins)<br>The Halt|2019|279(mins)<br>V: The Final Battle|1984|272(mins)<br>Atom Man vs. Superman|1950|252(mins)</p>
<h2 id="3-Q3-5-points-q3-oldest-people"><a href="#3-Q3-5-points-q3-oldest-people" class="headerlink" title="3. Q3 [5 points] (q3_oldest_people):"></a>3. Q3 [5 points] (q3_oldest_people):</h2><p>Determine the oldest people in the dataset who were born in or after 1900. You should assume that a person without a known death year is still alive.<br>Details: Print the name and age of each person. People should be ordered by a compound value of their age and secondly their name in alphabetical order. Return the first 20 results.<br>Your output should have the format: NAME|AGE</p>
<p>输入以下命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, substr(<span class="type">date</span>(<span class="string">&#x27;now&#x27;</span>),<span class="number">1</span>,<span class="number">4</span>) <span class="operator">-</span> born <span class="keyword">as</span> age <span class="keyword">FROM</span> people <span class="keyword">WHERE</span> born <span class="operator">&gt;</span> <span class="number">1900</span> <span class="keyword">AND</span> died <span class="keyword">is</span> <span class="keyword">NULL</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span>,name <span class="keyword">ASC</span> limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div>
<p>得到输出结果<br>Abdolhossein Sepenta|122<br>Annie Hémery|122<br>Bronislava Livia|122<br>Clemence Groves|122<br>Edward Poor Montgomery|122<br>Emmy Jülich|122<br>Eunice Howard|122<br>Florence ‘Pancho’ Barnes|122<br>Florence Klotz|122<br>Georg Tesche|122<br>Irene Russell|122<br>Itala Ferreira|122<br>Jack Gallagher|122<br>John Reed|122<br>Josef Walter|122<br>József Karbán|122<br>Kay MacCausland|122<br>Kiyoshi Kasuga|122<br>Mario Franchini|122<br>Pedro Aleixo|122</p>
<h2 id="4-Q4-10-points-q4-crew-appears-most"><a href="#4-Q4-10-points-q4-crew-appears-most" class="headerlink" title="4. Q4 [10 points] (q4_crew_appears_most):"></a>4. Q4 [10 points] (q4_crew_appears_most):</h2><p>Find the people who appear most frequently as crew members.<br>Details: Print the names and number of appearances of the 20 people with the most crew appearances ordered by their number of appearances in a descending fashion.<br>Your output should look like this: NAME|NUM_APPEARANCES</p>
<p>输入命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count</span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> people <span class="keyword">as</span> p , crew <span class="keyword">as</span> c</span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> p.person_id <span class="operator">=</span> c.person_id</span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">group</span> <span class="keyword">by</span> name</span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">order</span> <span class="keyword">by</span> count <span class="keyword">DESC</span></span><br><span class="line">  ...<span class="operator">&gt;</span> limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div>
<p>得到输出结果<br>Nivedita Basu|12564<br>Joel Beckerman|11286<br>Vic Sotto|10626<br>Ed McMahon|10153<br>Sameera Sherief|9905<br>Johnny Gilbert|9677<br>Erwin Romulo|8774<br>Ernesto Alonso|8471<br>Go Haruna|8454<br>Bradley Bell|8262<br>Helio Bannwart|7429<br>Danie Joubert|7340<br>Ginji Itô|7059<br>Shôichi Kuroki|7053<br>Duma Ndlovu|6865<br>Vaidehi Ramamurthy|6806<br>Sharad Tripathi|6649<br>Adrián Suar|5939<br>Mrinal Jha|5869<br>Jada Rowland|5763</p>
<h2 id="5-Q5-10-points-q5-decade-ratings"><a href="#5-Q5-10-points-q5-decade-ratings" class="headerlink" title="5. Q5 [10 points] (q5_decade_ratings):"></a>5. Q5 [10 points] (q5_decade_ratings):</h2><p>Compute intersting statistics on the ratings of content on a per-decade basis.<br>Details: Get the average rating (rounded to two decimal places), top rating, min rating, and the number of releases in each decade. Exclude titles which have not been premiered (i.e. where premiered is NULL). Print the relevant decade in a fancier format by constructing a string that looks like this: 1990s. Order the decades first by their average rating in a descending fashion and secondly by the decade, ascending, to break ties.<br>Your output should have the format: DECADE|AVG_RATING|TOP_RATING|MIN_RATING|NUM_RELEASES<br>输入命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ((t.premiered <span class="operator">/</span> <span class="number">10</span>) <span class="operator">*</span> <span class="number">10</span> )<span class="operator">||</span> <span class="string">&#x27;s&#x27;</span> <span class="keyword">AS</span> decade,</span><br><span class="line">  ...<span class="operator">&gt;</span>   ROUND(<span class="built_in">AVG</span>(r.rating), <span class="number">2</span>) <span class="keyword">AS</span> avg_rating,</span><br><span class="line">  ...<span class="operator">&gt;</span>   <span class="built_in">MAX</span>(r.rating) <span class="keyword">AS</span> max_rating,</span><br><span class="line">  ...<span class="operator">&gt;</span>   <span class="built_in">MIN</span>(r.rating) <span class="keyword">AS</span> min_rating,</span><br><span class="line">  ...<span class="operator">&gt;</span>   <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> num_releases</span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> titles <span class="keyword">AS</span> t, ratings <span class="keyword">AS</span> r</span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> t.title_id <span class="operator">=</span> r.title_id <span class="keyword">AND</span> t.premiered <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> decade</span><br><span class="line">  ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_rating <span class="keyword">DESC</span>, decade <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure></div>
<p>得到输出结果为<br>2020s|7.08|10.0|1.0|18825<br>2010s|7.05|10.0|1.0|73097<br>1960s|6.88|10.0|1.0|7423<br>2000s|6.85|10.0|1.0|39267<br>1990s|6.81|10.0|1.0|18177<br>1950s|6.77|10.0|1.0|4346<br>1970s|6.72|10.0|1.0|8929<br>1980s|6.72|10.0|1.0|11856<br>1940s|6.21|9.7|1.9|1872<br>1920s|6.04|8.9|1.0|915<br>1930s|6.0|9.4|1.1|1901<br>1910s|5.69|9.2|1.2|647<br>1870s|5.25|5.3|5.2|2<br>1880s|5.15|6.5|4.4|13<br>1900s|5.05|8.8|2.5|417<br>1890s|4.41|7.6|2.0|437</p>
<h2 id="6-Q6-10-points-q6-cruiseing-altitude"><a href="#6-Q6-10-points-q6-cruiseing-altitude" class="headerlink" title="6. Q6 [10 points] (q6_cruiseing_altitude):"></a>6. Q6 [10 points] (q6_cruiseing_altitude):</h2><p>Determine the most popular works with a person who has “Cruise” in their name and is born in 1962.<br>Details: Get the works with the most votes that have a person in the crew with “Cruise” in their name who was born in 1962. Return both the name of the work and the number of votes and only list the top 10 results in order from most to least votes. Make sure your output is formatted as follows: Top Gun|408389<br>JOIN ON 连表查询<br>JOIN和ON关键字通常一起使用，用于将两个或多个表中的数据联接起来。JOIN关键字指示要连接的表，而ON关键字指定连接条件。</p>
<p>输入命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> t.primary_title ,r.votes</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> titles t</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> ratings r <span class="keyword">ON</span> t.title_id <span class="operator">=</span> r.title_id</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> crew c <span class="keyword">ON</span> t.title_id <span class="operator">=</span> c.title_id</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> people p <span class="keyword">ON</span> c.person_id <span class="operator">=</span> p.person_id</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> p.name <span class="keyword">like</span> <span class="string">&#x27;%Cruise%&#x27;</span> <span class="keyword">and</span> p.born <span class="operator">=</span> <span class="number">1962</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> r.votes <span class="keyword">DESC</span> </span><br><span class="line">   ...<span class="operator">&gt;</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>
<p>得到输出结果为<br>Oblivion|520383<br>Mission: Impossible|423228<br>Top Gun|408389<br>Magnolia|311030<br>Born on the Fourth of July|106667<br>Days of Thunder|88698<br>Lions for Lambs|50257<br>Without Limits|7127<br>Space Station 3D|1693<br>Nickelodeon Kids’ Choice Awards 2012|212</p>
<h2 id="7-Q7-15-points-q7-year-of-thieves"><a href="#7-Q7-15-points-q7-year-of-thieves" class="headerlink" title="7. Q7 [15 points] (q7_year_of_thieves):"></a>7. Q7 [15 points] (q7_year_of_thieves):</h2><p>List the number of works that premiered in the same year that “Army of Thieves” premiered.<br>Details: Print only the total number of works. The answer should include “Army of Thieves” itself. For this question, determine distinct works by their title_id, not their names.</p>
<p>输入命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> titles</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> premiered <span class="operator">=</span> (<span class="keyword">SELECT</span> premiered <span class="keyword">from</span> titles <span class="keyword">WHERE</span> primary_title <span class="keyword">like</span> <span class="string">&#x27;Army of Thieves&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<p>得到输出结果<br>63843</p>
<h2 id="8-Q8-15-points-q8-kidman-colleagues"><a href="#8-Q8-15-points-q8-kidman-colleagues" class="headerlink" title="8. Q8 [15 points] (q8_kidman_colleagues):"></a>8. Q8 [15 points] (q8_kidman_colleagues):</h2><p>List the all the different actors and actresses who have starred in a work with Nicole Kidman (born in 1967).<br>Details: Print only the names of the actors and actresses in alphabetical order. The answer should include Nicole Kidman herself. Each name should only appear once in the output.<br>Note: As mentioned in the schema, when considering the role of an individual on the crew, refer to the field category. The roles “actor” and “actress” are different and should be accounted for as such.<br>输出命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> p1.name</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> people p1 </span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> crew c1 <span class="keyword">ON</span> p1.person_id <span class="operator">=</span> c1.person_id </span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> crew c2 <span class="keyword">ON</span> c1.title_id <span class="operator">=</span> c2.title_id </span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">JOIN</span> people p2 <span class="keyword">ON</span> c2.person_id <span class="operator">=</span> p2.person_id </span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> p2.name <span class="operator">=</span> <span class="string">&#x27;Nicole Kidman&#x27;</span> </span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">AND</span> p2.born <span class="operator">=</span> <span class="number">1967</span> </span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">AND</span> c1.category <span class="keyword">IN</span> (<span class="string">&#x27;actor&#x27;</span>, <span class="string">&#x27;actress&#x27;</span>) </span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> p1.name;</span><br></pre></td></tr></table></figure></div>
<p>得到结果<br>Betty Gilpin<br>Casey Affleck<br>Colin Farrell<br>Crista Flanagan<br>Danny Huston<br>Dennis Miller<br>Donald Sutherland<br>Ed Mantell<br>Fionnula Flanagan<br>Flora Cross<br>Fredrik Skavlan<br>Gus Mercurio<br>Halle Berry<br>Harris Yulin<br>J.K. Simmons<br>Jackson Bond<br>James Corden<br>Jason Bateman<br>Javier Bardem<br>Jesper Christensen<br>John Lithgow<br>Julianne Moore<br>Kai Lewins<br>Kyle Mooney<br>Lisa Flanagan<br>Liz Burch<br>Mahershala Ali<br>Maria Tran<br>Mark Strong<br>Nicholas Eadie<br>Nicole Kidman<br>Paul Bettany<br>Pauline Chan<br>Robert Pattinson<br>Russell Crowe<br>Sam Neill<br>Shailene Woodley<br>Sherie Graham<br>Simon Baker<br>Stellan Skarsgård<br>Tom Cruise<br>Valerie Yu<br>Veronica Lang<br>Will Ferrell</p>
<h2 id="9-Q9-15-points-q9-9th-decile-ratings"><a href="#9-Q9-15-points-q9-9th-decile-ratings" class="headerlink" title="9. Q9 [15 points] (q9_9th_decile_ratings):"></a>9. Q9 [15 points] (q9_9th_decile_ratings):</h2><p>For all people born in 1955, get their name and average rating on all movies they have been part of through their careers. Output the 9th decile of individuals as measured by their average career movie rating.<br>Details: Calculate average ratings for each individual born in 1955 across only the movies they have been part of. Compute the quantiles for each individual’s average rating using NTILE(10).<br>Make sure your output is formatted as follows (round average rating to the nearest hundredth, results should be ordered by a compound value of their ratings descending and secondly their name in alphabetical order): Stanley Nelson|7.13<br>Note: You should take quantiles after processing the average career movie rating of individuals. In other words, find the individuals who have an average career movie rating in the 9th decile of all individuals.</p>
<p>NTILE(10) 表示将结果集分为 10 个部分，每个部分中的行数大致相等。这里我们使用 NTILE 函数将人们按照职业生涯电影评级从高到低分成了 10 个部分。<br>OVER (ORDER BY AVG(r.rating) DESC, p.name) 制定了排序规则，即按照平均电影评级从高到低排序，如果平均电影评级相同，再按照人名从 A 到 Z 排序。这里我们使用 ORDER BY 子句对查询结果进行排序，以便将人们按照职业生涯电影评级从高到低排序。<br>AS decile 将查询结果的别名设置为 decile<br>输入命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">SELECT</span> name , ROUND(avg_rating, <span class="number">2</span>)</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> (</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">SELECT</span> p.name, <span class="built_in">NTILE</span>(<span class="number">10</span>) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(r.rating) <span class="keyword">DESC</span>, p.name) <span class="keyword">AS</span> decile, <span class="built_in">AVG</span>(r.rating) <span class="keyword">AS</span> avg_rating</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">FROM</span> people p</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">JOIN</span> crew c <span class="keyword">ON</span> p.person_id <span class="operator">=</span> c.person_id</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">JOIN</span> ratings r <span class="keyword">ON</span> c.title_id <span class="operator">=</span> r.title_id</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">WHERE</span> p.born <span class="operator">=</span> <span class="number">1955</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">GROUP</span> <span class="keyword">BY</span> p.person_id</span><br><span class="line">   ...<span class="operator">&gt;</span> )</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">WHERE</span> decile <span class="operator">=</span> <span class="number">9</span></span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_rating <span class="keyword">DESC</span>, name;</span><br></pre></td></tr></table></figure></div>
<p>得到输出结果<br>Kim Johnston Ulrich|5.5<br>Tom Huckabee|5.5<br>Marina Dyuzheva|5.47<br>John Delbridge|5.43<br>Cacá Amaral|5.4<br>Peter Atkins|5.4<br>Billy Blanks|5.35<br>Stéphane Clavier|5.35<br>Robert M. Sertner|5.3<br>Andrew Stevens|5.3<br>Sueli Aoki|5.2<br>Ángel Muñoz Alonso|5.1<br>Frank Di Pasquale|5.1<br>James Carroll|5.1<br>Masaaki Tezuka|5.1<br>Nicholas Mastandrea|5.1<br>Carmen Utrilla|5.0<br>Jim Gaines|5.0<br>Bolat Kalymbetov|4.9<br>Pablo Codevila|4.9<br>Zoltán David|4.9<br>Bubby Kent|4.8<br>Joy Grdnic|4.8</p>
<h2 id="10-Q10-15-points-q10-house-of-the-dragon"><a href="#10-Q10-15-points-q10-house-of-the-dragon" class="headerlink" title="10. Q10 [15 points] (q10_house_of_the_dragon):"></a>10. Q10 [15 points] (q10_house_of_the_dragon):</h2><p>Concatenate all the unique titles for the TV Series “House of the Dragon” as a string of comma-separated values in alphabetical order of the titles.<br>Details: Find all the unique dubbed titles for the new TV show “House of the Dragon” and order them alphabetically. Print a single string containing all these titles separated by commas.<br>Hint: You might find Recursive CTEs useful.<br>Note: Two titles are different even if they differ only in capitalization. Elements in the comma-separated value result should be separated with both a comma and a space, e.g. “foo, bar”.<br>SQLite3 特有的函数 group_concat 来连接字符串。具体来说，group_concat(title, ‘, ‘) 将 cte 查询的结果集中的 title 字段的所有值连接成一个字符串，并使用逗号和空格分隔它们。<br>输入命令</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte <span class="keyword">AS</span> (</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">lower</span>(primary_title) <span class="keyword">AS</span> title</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">FROM</span> titles</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;tvSeries&#x27;</span> <span class="keyword">AND</span> <span class="built_in">lower</span>(primary_title) <span class="keyword">LIKE</span> <span class="string">&#x27;%house of the dragon%&#x27;</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">UNION</span></span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">lower</span>(original_title) <span class="keyword">AS</span> title</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">FROM</span> titles</span><br><span class="line">   ...<span class="operator">&gt;</span>   <span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;tvSeries&#x27;</span> <span class="keyword">AND</span> <span class="built_in">lower</span>(original_title) <span class="keyword">LIKE</span> <span class="string">&#x27;%house of the dragon%&#x27;</span> <span class="keyword">AND</span> <span class="built_in">lower</span>(original_title) <span class="operator">&lt;&gt;</span> <span class="built_in">lower</span>(primary_title)</span><br><span class="line">   ...<span class="operator">&gt;</span> )</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">SELECT</span> group_concat(title, <span class="string">&#x27;, &#x27;</span>) <span class="keyword">AS</span> titles</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">FROM</span> cte</span><br><span class="line">   ...<span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> title;</span><br></pre></td></tr></table></figure></div>
<p>得到输出结果为<br>house of the dragon</p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title>RbTree Application of Interval Tree</title>
    <url>/2023/05/28/Fourth/</url>
    <content><![CDATA[<h1 id="实验四：区间树上重叠区间的查找算法"><a href="#实验四：区间树上重叠区间的查找算法" class="headerlink" title="实验四：区间树上重叠区间的查找算法"></a>实验四：区间树上重叠区间的查找算法</h1><h2 id="1-实验内容："><a href="#1-实验内容：" class="headerlink" title="(1)实验内容："></a>(1)实验内容：</h2><p>对红黑树进行修改，使其成为一颗区间数，并实现区间树上的重叠区间查找算法。待查询区间应由控制台输入，控制台直接打印查找结果</p>
<h2 id="2-实验目的："><a href="#2-实验目的：" class="headerlink" title="(2)实验目的："></a>(2)实验目的：</h2><p>通过实现红黑树的应用-区间树，来加深对红黑树的理解，并提高自己的编程能力，同时也能加深对区间树的理解。</p>
<h2 id="3-区间树的数据结构："><a href="#3-区间树的数据结构：" class="headerlink" title="(3)区间树的数据结构："></a>(3)区间树的数据结构：</h2><p>区间树的节点结构需要在红黑树的基础上再添加一个区间属性，也就是interval属性，以及以某个节点为根的的子树中所有区间的端点的最大值即max_end属性，其余属性与红黑树一致即可。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, interval</span>):</span><br><span class="line">        self.interval = interval <span class="comment"># 区间值</span></span><br><span class="line">        self.color = <span class="number">1</span> <span class="comment"># 初始为红色 1：代表红色 0：代表黑色</span></span><br><span class="line">        self.left = <span class="literal">None</span> <span class="comment"># 左子树</span></span><br><span class="line">        self.right = <span class="literal">None</span> <span class="comment"># 右子树</span></span><br><span class="line">        self.max_end = interval[<span class="number">1</span>]  <span class="comment">#max</span></span><br><span class="line">        self.parent = <span class="literal">None</span> <span class="comment"># 父节点</span></span><br></pre></td></tr></table></figure></div>
<h2 id="4-源码以及注释："><a href="#4-源码以及注释：" class="headerlink" title="(4)源码以及注释："></a>(4)源码以及注释：</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 区间树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, interval</span>):</span><br><span class="line">        self.interval = interval <span class="comment"># 区间值</span></span><br><span class="line">        self.color = <span class="number">1</span> <span class="comment"># 初始为红色 1：代表红色 0：代表黑色</span></span><br><span class="line">        self.left = <span class="literal">None</span> <span class="comment"># 左子树</span></span><br><span class="line">        self.right = <span class="literal">None</span> <span class="comment"># 右子树</span></span><br><span class="line">        self.max_end = interval[<span class="number">1</span>]  <span class="comment">#max</span></span><br><span class="line">        self.parent = <span class="literal">None</span> <span class="comment"># 父节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntervalTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 左旋操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leftRotate</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = x.right</span><br><span class="line">        x.right = y.left</span><br><span class="line">        <span class="keyword">if</span> y.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y.left.parent = x</span><br><span class="line">        y.parent = x.parent</span><br><span class="line">        <span class="keyword">if</span> x.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = y</span><br><span class="line">        <span class="keyword">elif</span> x == x.parent.left:</span><br><span class="line">            x.parent.left = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x.parent.right = y</span><br><span class="line">        y.left = x</span><br><span class="line">        x.parent = y</span><br><span class="line">        y.max_end = x.max_end</span><br><span class="line">        <span class="comment"># 递归更新节点的max值</span></span><br><span class="line">        <span class="keyword">while</span> x != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> x.right <span class="keyword">and</span> x.left:</span><br><span class="line">                x.max_end = <span class="built_in">max</span>(x.interval[<span class="number">1</span>],x.left.max_end,x.right.max_end)</span><br><span class="line">            <span class="keyword">elif</span> x.right:</span><br><span class="line">                x.max_end = <span class="built_in">max</span>(x.interval[<span class="number">1</span>],x.right.max_end)</span><br><span class="line">            <span class="keyword">elif</span> x.left:</span><br><span class="line">                x.max_end = <span class="built_in">max</span>(x.interval[<span class="number">1</span>],x.left.max_end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x.max_end = x.interval[<span class="number">1</span>]</span><br><span class="line">            x = x.parent</span><br><span class="line">    <span class="comment">#右旋操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightRotate</span>(<span class="params">self, y</span>):</span><br><span class="line">        x = y.left</span><br><span class="line">        y.left = x.right</span><br><span class="line">        <span class="keyword">if</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x.right.parent = y</span><br><span class="line">        x.parent = y.parent</span><br><span class="line">        <span class="keyword">if</span> y.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = x</span><br><span class="line">        <span class="keyword">elif</span> y == y.parent.left:</span><br><span class="line">            y.parent.left = x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.parent.right = x</span><br><span class="line">        x.right = y</span><br><span class="line">        y.parent = x</span><br><span class="line">        x.max_end = y.max_end</span><br><span class="line">        <span class="comment">#递归更新节点的max值</span></span><br><span class="line">        <span class="keyword">while</span> y != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> y.right <span class="keyword">and</span> y.left:</span><br><span class="line">                y.max_end = <span class="built_in">max</span>(y.interval[<span class="number">1</span>], y.left.max_end, y.right.max_end)</span><br><span class="line">            <span class="keyword">elif</span> y.right :</span><br><span class="line">                y.max_end = <span class="built_in">max</span>(y.interval[<span class="number">1</span>],y.right.max_end)</span><br><span class="line">            <span class="keyword">elif</span> y.left:</span><br><span class="line">                y.max_end = <span class="built_in">max</span>(y.interval[<span class="number">1</span>],y.left.max_end)</span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                y.max_end = y.interval[<span class="number">1</span>]</span><br><span class="line">            y = y.parent</span><br><span class="line">    <span class="comment"># 插入之后的调整操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">newInsertFixup</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="keyword">while</span> z.parent <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> z.parent.color == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> z.parent == z.parent.parent.left: <span class="comment"># 父节点为左子树</span></span><br><span class="line">                y = z.parent.parent.right   <span class="comment"># 叔叔节点</span></span><br><span class="line">                <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> y.color == <span class="number">1</span>:  <span class="comment"># 叔叔节点为红色</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    y.color = <span class="number">0</span> <span class="comment"># 将叔叔节点也置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    z = z.parent.parent <span class="comment"># 向上递归 继续处理</span></span><br><span class="line">                    <span class="comment"># 情况1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 叔叔节点为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> z == z.parent.right: <span class="comment"># 为父节点的右节点</span></span><br><span class="line">                        z = z.parent <span class="comment"># 对父节点进行左旋调整</span></span><br><span class="line">                        self.leftRotate(z) <span class="comment"># 左旋</span></span><br><span class="line">                        <span class="comment"># 情况2</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    self.rightRotate(z.parent.parent) <span class="comment"># 对父节点的父节点进行右旋处理</span></span><br><span class="line">                    <span class="comment"># 情况3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = z.parent.parent.left <span class="comment"># 父节点为右子树</span></span><br><span class="line">                <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> y.color == <span class="number">1</span>: <span class="comment"># 叔叔节点为红色</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    y.color = <span class="number">0</span> <span class="comment"># 将叔叔节点也置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    z = z.parent.parent <span class="comment"># 向上递归 继续处理</span></span><br><span class="line">                    <span class="comment"># 情况4</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 叔叔节点为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> z == z.parent.left: <span class="comment"># 为父节点的左节点</span></span><br><span class="line">                        z = z.parent <span class="comment"># 对父节点进行右旋调整</span></span><br><span class="line">                        self.rightRotate(z) <span class="comment"># 右旋</span></span><br><span class="line">                        <span class="comment"># 情况5</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    self.leftRotate(z.parent.parent) <span class="comment"># 对父节点的父节点进行左旋处理</span></span><br><span class="line">                    <span class="comment"># 情况6</span></span><br><span class="line">        self.root.color = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 插入红黑树节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, interval</span>):</span><br><span class="line">        z = NewNode(interval) <span class="comment"># 创建节点</span></span><br><span class="line">        y = <span class="literal">None</span></span><br><span class="line">        x = self.root</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> z.interval[<span class="number">0</span>] &lt; x.interval[<span class="number">0</span>]:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        z.parent = y</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = z</span><br><span class="line">        <span class="keyword">elif</span> z.interval[<span class="number">0</span>] &lt; y.interval[<span class="number">0</span>]:</span><br><span class="line">            y.left = z</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.right = z</span><br><span class="line">        z.max_end = z.interval[<span class="number">1</span>]</span><br><span class="line">        temp = z</span><br><span class="line">        <span class="comment">#递归更新父节点的max</span></span><br><span class="line">        <span class="keyword">while</span> z.parent != <span class="literal">None</span>:</span><br><span class="line">            z.parent.max_end = <span class="built_in">max</span>(z.parent.max_end, z.max_end)</span><br><span class="line">            z = z.parent</span><br><span class="line"></span><br><span class="line">        self.newInsertFixup(temp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraverse</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.inorderTraverse(node.left)</span><br><span class="line">            <span class="built_in">print</span>(node.interval)</span><br><span class="line">            <span class="built_in">print</span>(node.max_end)</span><br><span class="line">            self.inorderTraverse(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">overlaps</span>(<span class="params">self, interval</span>):</span><br><span class="line">        stack = [self.root]</span><br><span class="line">        <span class="comment"># 当前节点与目标区间重叠，将其添加到结果列表中</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 当前节点与查询区间重叠，加入返回结果中</span></span><br><span class="line">            <span class="keyword">if</span> node.interval[<span class="number">0</span>] &lt;= interval[<span class="number">1</span>] <span class="keyword">and</span> node.interval[<span class="number">1</span>] &gt;= interval[<span class="number">0</span>]:</span><br><span class="line">                res.append(node.interval)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果当前节点的左子树最大值大于区间的左端点，故可能包含重叠区间，则将其压入栈中继续查找</span></span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> node.left.max_end &gt;= interval[<span class="number">0</span>]:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            tempnode = node.right</span><br><span class="line">            <span class="comment"># 递归查询右子树最小值</span></span><br><span class="line">            <span class="keyword">while</span> tempnode:</span><br><span class="line">                <span class="built_in">min</span> = tempnode.interval[<span class="number">0</span>]</span><br><span class="line">                tempnode = tempnode.left</span><br><span class="line">            <span class="comment">#若右子树最小值大于区间右端点，则必不可能有重叠区间</span></span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">and</span> <span class="built_in">min</span> &lt;= interval[<span class="number">1</span>]:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="comment"># 返回结果列表</span></span><br><span class="line"></span><br><span class="line">res = []  <span class="comment"># 结果列表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 导入数据</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;insert.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        num_intervals = <span class="built_in">int</span>(f.readline().strip())</span><br><span class="line">        intervals = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_intervals):</span><br><span class="line">            start, end = <span class="built_in">map</span>(<span class="built_in">int</span>, f.readline().strip().split())</span><br><span class="line">            intervals.append((start, end))</span><br><span class="line"></span><br><span class="line">    tree = IntervalTree()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> intervals:</span><br><span class="line">        tree.insert(item)</span><br><span class="line">    input_tup = <span class="built_in">input</span>(<span class="string">&quot;输入区间，使用逗号分割：&quot;</span>) <span class="comment"># 输入字符串元组</span></span><br><span class="line">    tup = <span class="built_in">eval</span>(input_tup) <span class="comment"># 将字符串转为元组</span></span><br><span class="line">    tree.overlaps(tup)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<h2 id="（5）实验过程中遇到的困难以及收获："><a href="#（5）实验过程中遇到的困难以及收获：" class="headerlink" title="（5）实验过程中遇到的困难以及收获："></a>（5）实验过程中遇到的困难以及收获：</h2><p>难点：<br>对红黑树转化为区间树的调整不熟悉，由于开始画图画错了区间树，导致浪费了大量时间做无用功。<br>收获：<br>深入理解了红黑树的应用。通过实现区间树重叠区间查询算法，更深入地理解区间树，加深对数据结构和算法的理解和掌握。<br>提高了我的编程能力，加强了我的问题解决能力。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Introduction to Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>RbTree</title>
    <url>/2023/05/26/RbTree/</url>
    <content><![CDATA[<h1 id="实验三：红黑树插入算法"><a href="#实验三：红黑树插入算法" class="headerlink" title="实验三：红黑树插入算法"></a>实验三：红黑树插入算法</h1><h2 id="1、实验内容："><a href="#1、实验内容：" class="headerlink" title="1、实验内容："></a>1、实验内容：</h2><p>编码实现红黑树的插入算法，使得插入后依旧保持红黑性质。（即：实现教材 p178 页的 RB-INSERT, RB_INSERT_FIXUP 算法）并且将插入完成后的红黑树进行“先序遍历（NLR）”，“中序遍历（LNR）”和 “层次遍历（Level-Order Traverse）” 并将相应的遍历序列输出到文件中。 </p>
<h2 id="2、实验目的："><a href="#2、实验目的：" class="headerlink" title="2、实验目的："></a>2、实验目的：</h2><p>通过完成红黑树插入算法实验，可以加深对红黑树的理解，也能够加深对红黑树调整策略的理解。掌握其基本原理和实现方法，提高编程能力和数据结构算法的应用水平。</p>
<h2 id="3、算法设计思路："><a href="#3、算法设计思路：" class="headerlink" title="3、算法设计思路："></a>3、算法设计思路：</h2><p>红黑树插入算法的设计思路如下：<br>首先将新节点插入红黑树：插入操作类似于二叉搜索树的插入操作，首先找到新节点应该插入的位置，然后将其插入到红黑树中。新节点的默认颜色属性为红色，后续再调用FIXUP函数进行调整检查红黑树的性质：插入新节点后，可能会破坏红黑树的性质，需要进行修正。具体来说，需要检查新插入节点的父节点和叔叔节点的颜色进行对应的调整来进行红黑树的旋转操作，使其满足红黑树的性质。重复执行上述过程，直到红黑树的性质得以恢复。<br>总的来说，红黑树插入算法的设计思路是将新节点插入红黑树，并通过旋转操作和颜色变换等手段来保持红黑树性质得到满足。</p>
<h2 id="4、源码以及注释："><a href="#4、源码以及注释：" class="headerlink" title="4、源码以及注释："></a>4、源码以及注释：</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 红黑树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        self.key = key <span class="comment"># 值</span></span><br><span class="line">        self.color = <span class="number">1</span> <span class="comment"># 初始为红色 1：代表红色 0：代表黑色</span></span><br><span class="line">        self.left = <span class="literal">None</span> <span class="comment"># 左子树</span></span><br><span class="line">        self.right = <span class="literal">None</span> <span class="comment"># 右子树</span></span><br><span class="line">        self.parent = <span class="literal">None</span> <span class="comment"># 父节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 左旋操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leftRotate</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = x.right</span><br><span class="line">        x.right = y.left</span><br><span class="line">        <span class="keyword">if</span> y.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y.left.parent = x</span><br><span class="line">        y.parent = x.parent</span><br><span class="line">        <span class="keyword">if</span> x.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = y</span><br><span class="line">        <span class="keyword">elif</span> x == x.parent.left:</span><br><span class="line">            x.parent.left = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x.parent.right = y</span><br><span class="line">        y.left = x</span><br><span class="line">        x.parent = y</span><br><span class="line">    <span class="comment">#右旋操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightRotate</span>(<span class="params">self, y</span>):</span><br><span class="line">        x = y.left</span><br><span class="line">        y.left = x.right</span><br><span class="line">        <span class="keyword">if</span> x.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x.right.parent = y</span><br><span class="line">        x.parent = y.parent</span><br><span class="line">        <span class="keyword">if</span> y.parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = x</span><br><span class="line">        <span class="keyword">elif</span> y == y.parent.left:</span><br><span class="line">            y.parent.left = x</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.parent.right = x</span><br><span class="line">        x.right = y</span><br><span class="line">        y.parent = x</span><br><span class="line">    <span class="comment"># 插入之后的调整操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rbInsertFixup</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="keyword">global</span> record</span><br><span class="line">        <span class="keyword">while</span> z.parent <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> z.parent.color == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> z.parent == z.parent.parent.left: <span class="comment"># 父节点为左子树</span></span><br><span class="line">                y = z.parent.parent.right   <span class="comment"># 叔叔节点</span></span><br><span class="line">                <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> y.color == <span class="number">1</span>:  <span class="comment"># 叔叔节点为红色</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    y.color = <span class="number">0</span> <span class="comment"># 将叔叔节点也置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    z = z.parent.parent <span class="comment"># 向上递归 继续处理</span></span><br><span class="line">                    record.append(<span class="number">1</span>) <span class="comment"># 情况1</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 叔叔节点为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> z == z.parent.right: <span class="comment"># 为父节点的右节点</span></span><br><span class="line">                        z = z.parent <span class="comment"># 对父节点进行左旋调整</span></span><br><span class="line">                        self.leftRotate(z) <span class="comment"># 左旋</span></span><br><span class="line">                        record.append(<span class="number">2</span>) <span class="comment"># 情况2</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    self.rightRotate(z.parent.parent) <span class="comment"># 对父节点的父节点进行右旋处理</span></span><br><span class="line">                    record.append(<span class="number">3</span>) <span class="comment"># 情况3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y = z.parent.parent.left <span class="comment"># 父节点为右子树</span></span><br><span class="line">                <span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> y.color == <span class="number">1</span>: <span class="comment"># 叔叔节点为红色</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    y.color = <span class="number">0</span> <span class="comment"># 将叔叔节点也置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    z = z.parent.parent <span class="comment"># 向上递归 继续处理</span></span><br><span class="line">                    record.append(<span class="number">4</span>) <span class="comment"># 情况4</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 叔叔节点为黑色</span></span><br><span class="line">                    <span class="keyword">if</span> z == z.parent.left: <span class="comment"># 为父节点的左节点</span></span><br><span class="line">                        z = z.parent <span class="comment"># 对父节点进行右旋调整</span></span><br><span class="line">                        self.rightRotate(z) <span class="comment"># 右旋</span></span><br><span class="line">                        record.append(<span class="number">5</span>) <span class="comment"># 情况5</span></span><br><span class="line">                    z.parent.color = <span class="number">0</span> <span class="comment"># 将父节点置为黑色</span></span><br><span class="line">                    z.parent.parent.color = <span class="number">1</span> <span class="comment"># 将父节点的父节点置为红色</span></span><br><span class="line">                    self.leftRotate(z.parent.parent) <span class="comment"># 对父节点的父节点进行左旋处理</span></span><br><span class="line">                    record.append(<span class="number">6</span>)  <span class="comment"># 情况6</span></span><br><span class="line">        self.root.color = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 插入红黑树节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, key</span>):</span><br><span class="line">        z = RBTNode(key) <span class="comment"># 创建节点</span></span><br><span class="line">        y = <span class="literal">None</span></span><br><span class="line">        x = self.root</span><br><span class="line">        <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            y = x</span><br><span class="line">            <span class="keyword">if</span> z.key &lt; x.key:</span><br><span class="line">                x = x.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = x.right</span><br><span class="line">        z.parent = y</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = z</span><br><span class="line">        <span class="keyword">elif</span> z.key &lt; y.key:</span><br><span class="line">            y.left = z</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            y.right = z</span><br><span class="line">        self.rbInsertFixup(z)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraverse</span>(<span class="params">self, node</span>):</span><br><span class="line">        color = <span class="string">&quot;black&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment">#print(node.key, end=&#x27; &#x27;)</span></span><br><span class="line">            <span class="keyword">if</span> node.color == <span class="number">1</span>:</span><br><span class="line">                color = <span class="string">&quot;red&quot;</span></span><br><span class="line">            preList.append(<span class="built_in">str</span>(node.key) + <span class="string">&quot;, &quot;</span> + color)</span><br><span class="line">            self.preorderTraverse(node.left)</span><br><span class="line">            self.preorderTraverse(node.right)</span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraverse</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            color = <span class="string">&quot;black&quot;</span></span><br><span class="line">            self.inorderTraverse(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.color == <span class="number">1</span>:</span><br><span class="line">                color = <span class="string">&quot;red&quot;</span></span><br><span class="line">            inList.append(<span class="built_in">str</span>(node.key) + <span class="string">&quot;, &quot;</span> + color)</span><br><span class="line">            self.inorderTraverse(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 层序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderTraverse</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(self.root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) != <span class="number">0</span>:</span><br><span class="line">            color = <span class="string">&quot;black&quot;</span></span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.color == <span class="number">1</span>:</span><br><span class="line">                color = <span class="string">&quot;red&quot;</span></span><br><span class="line">            levelList.append(<span class="built_in">str</span>(node.key) + <span class="string">&quot;, &quot;</span> + color)</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line"><span class="comment"># 全局变量定义</span></span><br><span class="line">record = []</span><br><span class="line">preList = []</span><br><span class="line">inList = []</span><br><span class="line">levelList = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    data = []</span><br><span class="line">    <span class="comment"># 导入数据</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;insert.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        nums = f.readline()</span><br><span class="line">        data = f.read().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, data)) <span class="comment"># 将str转化为int</span></span><br><span class="line"></span><br><span class="line">    rbTree = RBTree() <span class="comment"># 创建红黑树</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">        rbTree.insert(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印红黑树</span></span><br><span class="line">    rbTree.preorderTraverse(rbTree.root)</span><br><span class="line">    rbTree.inorderTraverse(rbTree.root)</span><br><span class="line">    rbTree.levelOrderTraverse()</span><br><span class="line">    <span class="built_in">print</span>(record)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./NLR.txt&quot;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> preList:</span><br><span class="line">            f.write(<span class="built_in">str</span>(item) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./LNR.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> inList:</span><br><span class="line">            f.write(<span class="built_in">str</span>(item) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./LOT.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> levelList:</span><br><span class="line">            f.write(<span class="built_in">str</span>(item) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>


]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Introduction to Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>QuickSort</title>
    <url>/2023/05/26/The_First/</url>
    <content><![CDATA[<h1 id="实验一：快速排序算法及其优化"><a href="#实验一：快速排序算法及其优化" class="headerlink" title="实验一：快速排序算法及其优化"></a>实验一：快速排序算法及其优化</h1><h2 id="1、算法核心思想："><a href="#1、算法核心思想：" class="headerlink" title="1、算法核心思想："></a>1、算法核心思想：</h2><p>首先采用随机基准选择来优化由于基准选择不当导致的最坏时间复杂度，由于本次实验是给定具体实验数据，故随机基准选择的优化并不是很明显，因此采用运行标准快速排序与优化后的快速排序各20次，算其平均时间来考察是否进行了优化。<br>其次采用了当数组规模小于某个临界值（14）时采取插入排序来提高算法的运行速度。<br>综上所述，我的算法是采用随机基准以及插入排序来进行对标准快速排序算法的优化。</p>
<h2 id="2、算法的核心代码："><a href="#2、算法的核心代码：" class="headerlink" title="2、算法的核心代码："></a>2、算法的核心代码：</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment">#标准快速排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">array, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        q = partition(array, l, r)</span><br><span class="line">        quick_sort(array, l, q - <span class="number">1</span>)</span><br><span class="line">        quick_sort(array, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment">#取最后一个数作为基准</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">array, l, r</span>):</span><br><span class="line">    x = array[r]</span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt;= x:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">    array[i + <span class="number">1</span>], array[r] = array[r], array[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#插入排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">array, left, right</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left + <span class="number">1</span>, right + <span class="number">1</span>):</span><br><span class="line">        key_item = array[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= left <span class="keyword">and</span> array[j] &gt; key_item:</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        array[j + <span class="number">1</span>] = key_item</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机选择基准</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition_random</span>(<span class="params">array, l, r</span>):</span><br><span class="line">    <span class="comment"># 随机选取基准点</span></span><br><span class="line">    rnd_index = random.randint(l, r)</span><br><span class="line">    array[rnd_index], array[r] = array[r], array[rnd_index]</span><br><span class="line"></span><br><span class="line">    x = array[r]</span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt; x:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line"></span><br><span class="line">    array[i + <span class="number">1</span>], array[r] = array[r], array[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#优化后的快速排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_good</span>(<span class="params">array, l, r</span>):</span><br><span class="line">    <span class="keyword">if</span> r - l + <span class="number">1</span> &lt;= <span class="number">14</span>: <span class="comment">#元素少于某个界限，使用插入排序优化算法</span></span><br><span class="line">        insertion_sort(array, l, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        q = partition_random(array, l, r)</span><br><span class="line">        quick_good(array, l, q - <span class="number">1</span>)</span><br><span class="line">        quick_good(array, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment">#归并排序算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 找到中间点</span></span><br><span class="line">        mid = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 分割成两个子数组</span></span><br><span class="line">        left_arr = arr[:mid]</span><br><span class="line">        right_arr = arr[mid:]</span><br><span class="line">        <span class="comment"># 对子数组递归地进行归并排序</span></span><br><span class="line">        merge_sort(left_arr)</span><br><span class="line">        merge_sort(right_arr)</span><br><span class="line">        <span class="comment"># 合并两个有序子数组</span></span><br><span class="line">        i = j = k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_arr) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right_arr):</span><br><span class="line">            <span class="keyword">if</span> left_arr[i] &lt; right_arr[j]:</span><br><span class="line">                arr[k] = left_arr[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                arr[k] = right_arr[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 处理剩余的元素</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left_arr):</span><br><span class="line">            arr[k] = left_arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(right_arr):</span><br><span class="line">            arr[k] = right_arr[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    data = f.readline()</span><br><span class="line">    data = f.read().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    int_data = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, data)) <span class="comment">#将列表元素转化成int整型</span></span><br><span class="line">    time1 = <span class="number">0</span>  <span class="comment">#标准快排累计20次的总时间</span></span><br><span class="line">    time2 = <span class="number">0</span>  <span class="comment">#优化快排累计20次的总时间</span></span><br><span class="line">    time3 = <span class="number">0</span>  <span class="comment">#归并排序累计20次的总时间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">20</span>):</span><br><span class="line">        list_arr = <span class="built_in">list</span>(int_data) <span class="comment">#用于标准快排测试</span></span><br><span class="line">        list_temp = <span class="built_in">list</span>(int_data) <span class="comment">#用于优化快排测试</span></span><br><span class="line">        list_merge = <span class="built_in">list</span>(int_data) <span class="comment">#用于归并排序测试</span></span><br><span class="line">        start2 = time()</span><br><span class="line">        quick_good(list_temp,<span class="number">0</span>,<span class="built_in">len</span>(list_temp) - <span class="number">1</span>)</span><br><span class="line">        end2 = time()</span><br><span class="line">        time2 += end2 - start2</span><br><span class="line">        start = time()</span><br><span class="line">        quick_sort(list_arr, <span class="number">0</span>, <span class="built_in">len</span>(list_arr) - <span class="number">1</span>)</span><br><span class="line">        end = time()</span><br><span class="line">        time1 += end - start</span><br><span class="line">        start3 = time()</span><br><span class="line">        merge_sort(list_merge)</span><br><span class="line">        end3 = time()</span><br><span class="line">        time3 += end3 - start3</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;标准快排的20次平均运行时间为：&quot;</span> + <span class="built_in">str</span>(time1 / <span class="number">20</span>) + <span class="string">&quot;s&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优化快排的20次平均运行时间为：&quot;</span> + <span class="built_in">str</span>(time2 / <span class="number">20</span>) + <span class="string">&quot;s&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;归并排序的20次平均运行时间为：&quot;</span> + <span class="built_in">str</span>(time3 / <span class="number">20</span>) + <span class="string">&quot;s&quot;</span>)</span><br><span class="line">    path = <span class="string">&quot;./sorted.txt&quot;</span> <span class="comment">#写出相对路径</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> s:</span><br><span class="line">        s.write(<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, list_temp))) <span class="comment">#将列表数据转化成str并写入到文件中</span></span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<h2 id="3、实验结果分析："><a href="#3、实验结果分析：" class="headerlink" title="3、实验结果分析："></a>3、实验结果分析：</h2><p>在当前环境和数据下，优化后的快排比标准快排稍快一些，比归并排序快了很多。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Introduction to Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Closest Point Pair</title>
    <url>/2023/05/26/The_Second/</url>
    <content><![CDATA[<h1 id="实验二：求平面上-n-个顶点的最近点对问题"><a href="#实验二：求平面上-n-个顶点的最近点对问题" class="headerlink" title="实验二：求平面上 n 个顶点的最近点对问题"></a>实验二：求平面上 n 个顶点的最近点对问题</h1><h2 id="1、实验内容："><a href="#1、实验内容：" class="headerlink" title="1、实验内容："></a>1、实验内容：</h2><p>计算平面上n个坐标点之间的距离，求得距离最近的点对编号，以及最近的点对距离。使用分治算法来高效的解决问题，并与朴素算法进行运行时间的对比参照。</p>
<h2 id="2、算法设计思路："><a href="#2、算法设计思路：" class="headerlink" title="2、算法设计思路："></a>2、算法设计思路：</h2><p>首先从data.txt文件中读取数据到一个元组组成的列表中，元组中有三个属性，第一个为编号，第二和第三个分别为x，y坐标。之后对数据进行预处理，根据元组的x坐标进行从小到大排序，之后选取中间坐标作为切分依据，将左边的点放到left中，右边的点放到right中。之后进行递归求解左右两部分的最近点对。由于最近点对可能横跨中心线，故根据前面递归求解的最近距离（min_distance），以及点对信息进行处理，中点横坐标为mx，将不在（mx-min_distance,mx+distance）范围内的点剔除，将符合条件的点存入到y’列表中，之后循环计算y’中的点与其后至多7个点的距离，如果比min_distance小，就更新点对信息以及最近距离信息。</p>
<h2 id="3、源码以及注释："><a href="#3、源码以及注释：" class="headerlink" title="3、源码以及注释："></a>3、源码以及注释：</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">p1, p2</span>):</span><br><span class="line">    <span class="keyword">return</span> math.sqrt((p1[<span class="number">1</span>] - p2[<span class="number">1</span>]) ** <span class="number">2</span> + (p1[<span class="number">2</span>] - p2[<span class="number">2</span>]) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 朴素算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">direct_cal</span>(<span class="params">points</span>):</span><br><span class="line">    min_distance = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    n = <span class="built_in">len</span>(points)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">            dist = distance(points[i], points[j])</span><br><span class="line">            <span class="keyword">if</span> dist &lt; min_distance:</span><br><span class="line">                min_distance = dist</span><br><span class="line">                closest = (points[i][<span class="number">0</span>], points[j][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> min_distance, closest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closepoint_mid</span>(<span class="params">points_x, points_y, minDistance, closet</span>):</span><br><span class="line">    <span class="comment"># 计算横跨分割线的情况</span></span><br><span class="line">    mx = points_x[<span class="built_in">len</span>(points_x) // <span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">    pointsy = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#建立y‘,将在约定范围内的点保存到y&#x27;中</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> points_y:</span><br><span class="line">        <span class="keyword">if</span> mx - minDistance &lt;= item[<span class="number">1</span>] <span class="keyword">and</span> item[<span class="number">1</span>] &lt;= mx + minDistance:</span><br><span class="line">            pointsy.append(item)</span><br><span class="line"></span><br><span class="line">    mindis = minDistance</span><br><span class="line"></span><br><span class="line">    len_y = <span class="built_in">len</span>(pointsy)</span><br><span class="line">    <span class="comment"># 计算p后的至多7个点之间的距离</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len_y - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">min</span>(i + <span class="number">8</span>, len_y)):</span><br><span class="line">            dist = distance(pointsy[i], pointsy[j])</span><br><span class="line">            <span class="keyword">if</span> dist &lt; mindis:</span><br><span class="line">                closet = (pointsy[i], pointsy[j])</span><br><span class="line">                mindis = dist</span><br><span class="line">    <span class="keyword">return</span> closet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算最近点对</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closepoint_landr</span>(<span class="params">points_x, points_y</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(points_x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> direct_cal(points_x)</span><br><span class="line">    <span class="comment"># 切分 左部分和右部分</span></span><br><span class="line">    left_x = points_x[:n // <span class="number">2</span>]</span><br><span class="line">    right_x = points_x[n // <span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line">    left_y = []</span><br><span class="line">    right_y = []</span><br><span class="line"></span><br><span class="line">    mid = left_x[-<span class="number">1</span>][<span class="number">1</span>]  <span class="comment"># 中间点坐标的x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照中间点坐标x进行切分y</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> points_y:</span><br><span class="line">        <span class="keyword">if</span> (item[<span class="number">1</span>] &lt; mid):</span><br><span class="line">            left_y.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right_y.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归求解左半部和右半部</span></span><br><span class="line">    min_distance, closest = <span class="built_in">min</span>(closepoint_landr(left_x, left_y), closepoint_landr(right_x, right_y))</span><br><span class="line"></span><br><span class="line">    min_mid = closepoint_mid(points_x, points_y, min_distance, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> min_mid <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> distance(min_mid[<span class="number">0</span>], min_mid[<span class="number">1</span>]), (min_mid[<span class="number">0</span>][<span class="number">0</span>], min_mid[<span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> min_distance, closest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="built_in">id</span>, x, y = line.strip().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">            points.append((<span class="built_in">int</span>(<span class="built_in">id</span>), <span class="built_in">float</span>(x), <span class="built_in">float</span>(y)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预处理数据，按照x坐标对点对进行排序</span></span><br><span class="line">    points.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    starttime = time()</span><br><span class="line">    mindistance, <span class="built_in">id</span> = closepoint_landr(points, points[:])</span><br><span class="line">    endtime = time()</span><br><span class="line">    starttime_direct = time()</span><br><span class="line">    min_distance , id_temp = direct_cal(points)</span><br><span class="line">    endtime_direct = time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;使用朴素算法得到的最近点对编号为<span class="subst">&#123;id_temp&#125;</span>,最近的点对距离为<span class="subst">&#123;min_distance&#125;</span>,所用时间为<span class="subst">&#123;endtime_direct - starttime_direct&#125;</span>s&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;使用分治算法得到的最近点对编号为<span class="subst">&#123;<span class="built_in">id</span>&#125;</span>,最近的点对距离为<span class="subst">&#123;mindistance&#125;</span>,所用时间为<span class="subst">&#123;endtime - starttime&#125;</span>s&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<p>4、算法测试结果以及分析，与朴素算法时间对比：<br>朴素算法所用时间约为200倍，朴所用时间为22s左右，而分治算法用时大概0.11s</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Introduction to Algorithms</tag>
      </tags>
  </entry>
</search>
